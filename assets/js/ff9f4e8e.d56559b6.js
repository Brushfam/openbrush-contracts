"use strict";(self.webpackChunkopenbrush=self.webpackChunkopenbrush||[]).push([[62489],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(n),h=r,d=u["".concat(l,".").concat(h)]||u[h]||m[h]||o;return n?a.createElement(d,s(s({ref:t},p),{},{components:n})):a.createElement(d,s({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8296:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={sidebar_position:1,title:"Overview"},s=void 0,i={unversionedId:"smart-contracts/overview",id:"version-v4.0.0-beta/smart-contracts/overview",title:"Overview",description:"This doc contains description of how the OpenBrush library can be imported and used.",source:"@site/versioned_docs/version-v4.0.0-beta/smart-contracts/overview.md",sourceDirName:"smart-contracts",slug:"/smart-contracts/overview",permalink:"/openbrush-contracts/v4.0.0-beta/smart-contracts/overview",draft:!1,editUrl:"https://github.com/727-Ventures/openbrush-contracts/tree/main/docs/versioned_docs/version-v4.0.0-beta/smart-contracts/overview.md",tags:[],version:"v4.0.0-beta",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Overview"},sidebar:"tutorialSidebar",previous:{title:"Getting started",permalink:"/openbrush-contracts/v4.0.0-beta/"},next:{title:"Upgradeable contract",permalink:"/openbrush-contracts/v4.0.0-beta/smart-contracts/upgradeable"}},l={},c=[{value:"The default <code>toml</code> of your project with OpenBrush:",id:"the-default-toml-of-your-project-with-openbrush",level:4},{value:"Reuse implementation of traits from OpenBrush",id:"reuse-implementation-of-traits-from-openbrush",level:4}],p={toc:c},u="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This doc contains description of how the OpenBrush library can be imported and used."),(0,r.kt)("p",null,"The OpenBrush is using ink! version ",(0,r.kt)("inlineCode",{parentName:"p"},"4.2.1")," at the moment.\nYou will need to use the same version of ink! in your project.\nIf you use a different version of ink, you need to use a different version of OpenBrush which uses the same version of ink!.\nOpenBrush had several significant changes in API, so you check the ",(0,r.kt)("a",{parentName:"p",href:"https://openbrush.io"},"Wizard"),"\nto study how to use different versions of OpenBrush."),(0,r.kt)("p",null,"The documentation describes the latest available OpenBrush and how to use it.\nIt doesn't contain ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/supercolony-net/openbrush-contracts/issues/127"},"versioning")," yet."),(0,r.kt)("h4",{id:"the-default-toml-of-your-project-with-openbrush"},"The default ",(0,r.kt)("inlineCode",{parentName:"h4"},"toml")," of your project with OpenBrush:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'[package]\nname = "name_of_contract"\nversion = "1.0.0"\nauthors = ["The best developer ever"]\nedition = "2023"\n\n[dependencies]\n# Import ink!\nink = { version = "4.2.1", default-features = false}\n\nscale = { package = "parity-scale-codec", version = "3", default-features = false, features = ["derive"] }\nscale-info = { version = "2.6", default-features = false, features = ["derive"], optional = true }\n\n# OpenBrush dependency\nopenbrush = { git = "https://github.com/Brushfam/openbrush-contracts", branch = "develop", default-features = false }\n\n[lib]\nname = "name_of_contract"\npath = "lib.rs"\n\n[features]\ndefault = ["std"]\nstd = [\n  "ink/std",\n  "scale/std",\n  "scale-info/std",\n  # OpenBrush dependency\n  "openbrush/std",\n]\nink-as-dependency = []\n')),(0,r.kt)("p",null,"By default, the ",(0,r.kt)("inlineCode",{parentName:"p"},"openbrush")," crate provides ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Brushfam/openbrush-contracts/blob/main/lang/macro/src/lib.rs"},"macros"),"\nfor simplification of the development and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Brushfam/openbrush-contracts/tree/main/contracts/src/traits"},"traits")," of\ncontracts (you can implement them by yourself, and you can use them for cross-contract calls)."),(0,r.kt)("p",null,"OpenBrush also provides the default implementation of traits that can be enabled via crate features.\nA list of all available features you can find ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Brushfam/openbrush-contracts/blob/main/Cargo.toml#L51"},"here"),".\nThe default features are implemented by a ",(0,r.kt)("inlineCode",{parentName:"p"},"#[openbrush::implentation]")," macro, by providing the trait name you want to implement, and functions from the default implementation can be overriden using the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[overrider]")," attribute. If you want to use the default implementation of a function, while adding some modifier to the function, you can do so with the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[default_impl]")," attribute. Both of these attribute take the name of the trait we are overriding the method in as argument. Some default implementations come with several traits containing methods that can be overriden. We can override any function in any trait with these attributes. An example PSP22 with some overriden functions would look like this: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std, no_main)]\n\n// This will add the default implementation of PSP22 and PSP22Mintable\n#[openbrush::implementation(PSP22, PSP22Mintable, Ownable)] \n// This macro will collect the traits and override them. Make sure it comes after the implementation macro!\n#[openbrush::contract] \npub mod psp22_example {\n  // derive macro which implements traits needed for a proper Storage manipulation within OB standards\n  use openbrush::traits::Storage; \n  use ink::storage::traits::ManualKey;\n  use ink::storage::traits::Lazy;\n  #[ink(storage)] // needed for the ink! contract storage struct\n  // this will implement traits needed for OB standards to work with the contract storage struct\n  #[derive(Storage, Default)] \n  pub struct PSP22Example {\n    // we have to add the data structs needed to work with the implemented traits to the storage\n    // the fields need to be marked with this attribute in order for the contract to implement neede traits\n    #[storage_field] \n    psp22: psp22::Data,\n    #[storage_field]\n    ownable: ownable::Data,\n    // here we can add any other fields needed for our contract\n    // we will add logic which bans a user from transferring the token\n    // we will make it lazy and set it a manual storage key so we can upgrade this contract in future\n    banned_account: Lazy<AccountId, ManualKey<123>>\n  }\n\n  #[default_impl(PSP22Mintable)] // we will add some attributes to the mint function in PSP22Mintable\n  #[modifiers(ownable::only_owner)] // this will be moved to the PSP22Mintable::mint along with any other attributes\n  fn mint() { \n    // the default_impl attribute only cares about the function name and the trait name\n    // in which we want to override the method, therefore we can omit all parameters and return types. \n    // default_impl macro will use the original body of the function, so here we can keep it empty as well.\n  }\n\n  #[overrider(psp22::Internal)] // we want to override psp22::Internal::_before_token_transfer method\n  fn _before_token_transfer(\n    &mut self,\n    from: Option<&AccountId>,\n    _to: Option<&AccountId>,\n    _amount: &Balance,\n  ) -> Result<(), PSP22Error> {\n    if from == self.banned_account.get() {\n      return Err(PSP22Error::InsufficientAllowance)\n    }\n    Ok(())\n  }\n\n  impl Contract {\n    #[ink(constructor)]\n    pub fn new(total_supply: Balance) -> Self {\n      let mut instance = Self::default();\n\n      psp22::Internal::_mint_to(&mut instance, Self::env().caller(), total_supply).expect("Should mint");\n      ownable::Internal::_init_with_owner(&mut instance, Self::env().caller());\n      // private key of 0x0 is known, so we ban transfers from this account and users can safely use it as burn address!\n      instance.banned_account.set([0u8; 32]); \n\n      instance\n    }\n  }\n}\n')),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"ink! requires to put ",(0,r.kt)("inlineCode",{parentName:"p"},'#![cfg_attr(not(feature = "std"), no_std, no_main)]')," at the top of root crate.")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"The standards implemented in OpenBrush support events, but user has to specify this in their contract. ink! events have to be defined in the contract mod, meaning you have to emit them in the contract mod. You can do this by overriding the default _emit_xxx_event methods in different standards. There is currently a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/paritytech/ink/pull/1827"},"PR in ink!")," which will allow us to define events anywhere, and we will reflect this change in OB as well!")),(0,r.kt)("h4",{id:"reuse-implementation-of-traits-from-openbrush"},"Reuse implementation of traits from OpenBrush"),(0,r.kt)("p",null,"The doc contains links to the examples of how to reuse and customize the default implementation of traits."),(0,r.kt)("p",null,"All default implementations of the traits provided by OpenBrush have the same pattern.\nConsequently, the re-usage of each implementation in your contract also has the same pattern."),(0,r.kt)("p",null,"Each implementation of the contract has its module and its feature that enables that\nmodule. A list of available modules you can find ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Brushfam/openbrush-contracts/blob/main/contracts/src/lib.rs#L33"},"here"),",\na list of available features ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Brushfam/openbrush-contracts/blob/main/Cargo.toml#L51"},"here"),".\nEach module can be reached via the ",(0,r.kt)("inlineCode",{parentName:"p"},"openbrush::contracts::")," namespace. For example,\nto use the ",(0,r.kt)("inlineCode",{parentName:"p"},"psp22")," module, you need to import ",(0,r.kt)("inlineCode",{parentName:"p"},"openbrush::contracts::psp22"),";\nto use the ",(0,r.kt)("inlineCode",{parentName:"p"},"ownable")," module, you need to import ",(0,r.kt)("inlineCode",{parentName:"p"},"openbrush::contracts::ownable"),". It is not needed to import the modules when using the ",(0,r.kt)("inlineCode",{parentName:"p"},"implementation")," macro, the macro will do it for you."),(0,r.kt)("p",null,"Before importing each module (manually or with the macro), first you need to enable the corresponding feature in your ",(0,r.kt)("inlineCode",{parentName:"p"},"Cargo.toml"),".\nThe name of the feature is the same as the name of the module. For example:"),(0,r.kt)("p",null,"To enable ",(0,r.kt)("inlineCode",{parentName:"p"},"psp22"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'openbrush = { git = "https://github.com/Brushfam/openbrush-contracts", branch = "develop", default-features = false, features = ["psp22"] }\n')),(0,r.kt)("p",null,"To enable ",(0,r.kt)("inlineCode",{parentName:"p"},"ownable"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'openbrush = { git = "https://github.com/Brushfam/openbrush-contracts", branch = "develop", default-features = false, features = ["ownable"] }\n')),(0,r.kt)("p",null,"To enable both:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'openbrush = { git = "https://github.com/Brushfam/openbrush-contracts", branch = "develop", default-features = false, features = ["psp22, ownable"] }\n')),(0,r.kt)("p",null,"After enabling the feature and importing the corresponding module, you need to embed the module\ndata structure into your contract as a field and implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"openbrush::traits::Storage"),"\ntrait for that field. In most cases, the data structure of each module is named ",(0,r.kt)("inlineCode",{parentName:"p"},"Data"),".\nIf importing several modules, you can specify which data you want to use via namespaces like\n",(0,r.kt)("inlineCode",{parentName:"p"},"psp22::Data")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"ownable::Data"),"."),(0,r.kt)("p",null,"Embedding of data structures looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use openbrush::contracts::ownable::*;\nuse openbrush::contracts::psp22::*;\n\n#[ink(storage)]\npub struct Contract {\n    foo: psp22::Data,\n    bar: ownable::Data,\n}\n")),(0,r.kt)("p",null,"Each contract that wants to reuse implementation should implement the\n",(0,r.kt)("inlineCode",{parentName:"p"},"openbrush::traits::Storage")," with the corresponding data structure.\nThe easiest way to implement that trait is via the derive macro by adding\n",(0,r.kt)("inlineCode",{parentName:"p"},"#[derive(Storage)]")," and marking the corresponding fields with the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[storage_field]"),"\nattribute."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use openbrush::contracts::ownable::*;\nuse openbrush::contracts::psp22::*;\nuse openbrush::traits::Storage;\n\n#[ink(storage)]\n#[derive(Storage)]\npub struct Contract {\n    #[storage_field]\n    foo: psp22::Data,\n    #[storage_field]\n    bar: ownable::Data,\n}\n")),(0,r.kt)("p",null,"Now your contract has access to default implementation on the Rust level.\nIt is on the Rust level so you can call methods only inside your contract\n(in the example, it is methods of ",(0,r.kt)("inlineCode",{parentName:"p"},"PSP22"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"psp22::Internal"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Ownable"),", and\n",(0,r.kt)("inlineCode",{parentName:"p"},"ownable::Internal")," traits). You can implement the traits yourself if you need\na custom behavior of OpenBrush-defined standard. In most cases, you want to\ninherit the behavior of OpenBrush standard and do some modifications in its behavior.\nYou can do it with the ",(0,r.kt)("inlineCode",{parentName:"p"},"#[openbrush::implementation]")," macro. We can omit the imports\nfor ownable and psp22 as they will be imported with the macro."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[openbrush::implementation(PSP22, Ownable)]\n#[openbrush::contract]\npub mod my_psp22 {\n    use openbrush::traits::Storage;\n\n    #[ink(storage)]\n    #[derive(Storage)]\n    pub struct Contract {\n        #[storage_field]\n        foo: psp22::Data,\n        #[storage_field]\n        bar: ownable::Data,\n    }\n}\n")),(0,r.kt)("p",null,"Remember, only traits with ",(0,r.kt)("inlineCode",{parentName:"p"},"#[ink(message)]")," methods can be public. ",(0,r.kt)("inlineCode",{parentName:"p"},"psp22::Internal"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"ownable::Internal")," can't be exposed. It is for internal usage only."),(0,r.kt)("p",null,'The implementation in OpenBrush is called "default" because you can customize (override) it.\nYou can override any method from any trait with the ',(0,r.kt)("inlineCode",{parentName:"p"},"#[overrider]")," macro, by passing the\nname of trait the method belongs to. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[openbrush::implementation(PSP22, Ownable)]\n#[openbrush::contract]\npub mod my_psp22 {\n  use openbrush::traits::Storage;\n\n  #[ink(storage)]\n  #[derive(Storage)]\n  pub struct Contract {\n      #[storage_field]\n      foo: psp22::Data,\n      #[storage_field]\n      bar: ownable::Data,\n  }\n\n  #[overrider(PSP22)]\n  fn balance_of(&self, owner: AccountId) -> Balance {\n    // For example you can break `balance_of` method and return always zero\n    return 0\n  }\n\n  #[overrider(Ownable)]\n  fn owner(&self) -> Option<AccountId> {\n    // For example you can return always zero owner\n    None\n  }\n\n  #[overrider(psp22::Internal)]\n  fn _mint(&mut self, account: AccountId, amount: Balance) -> Result<(), PSP22Error> {\n    return Err(PSP22Error::Custom("I don\'t want to mint anything".to_string()));\n  }\n\n  #[overrider(ownable::Internal)]\n  fn _init_with_owner(&mut self, owner: AccountId) {\n    // Maybe you want to change something during initialization of the owner\n  }\n')),(0,r.kt)("p",null,"Work with each module has the same pattern. The difference is only in the naming of\nthe module and main trait. Some contract extensions require additional steps, so below,\nyou can find instructions on how to work with them:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/PSP22/"},"PSP22")," is an example of how you can reuse the implementation of\n",(0,r.kt)("a",{parentName:"li",href:"https://github.com/Brushfam/openbrush-contracts/tree/main/contracts/src/token/psp22"},"psp22"),". You also can find examples of how to reuse extensions.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/PSP22/Extensions/metadata"},"PSP22Metadata"),": metadata for PSP22."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/PSP22/Extensions/mintable"},"PSP22Mintable"),": creation of new tokens."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/PSP22/Extensions/burnable"},"PSP22Burnable"),": destruction of own tokens."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/PSP22/Extensions/wrapper"},"PSP22Wrapper"),": wrapper for PSP22 token (useful for governance tokens etc.)."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/PSP22/Extensions/flashmint"},"PSP22FlashMint"),": extension which allows performing flashloans of the token by minting and burning the token."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/pausable"},"PSP22Pausable"),": example of using pausable extension in the PSP22 contract."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/PSP22/Utils/token-timelock"},"PSP22TokenTimelock"),": Utility which allows token holders to lock their tokens for a specified amount of time."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/PSP34/"},"PSP34")," is an example of how you can reuse the implementation of\n",(0,r.kt)("a",{parentName:"li",href:"https://github.com/Brushfam/openbrush-contracts/tree/main/contracts/src/token/psp34"},"psp34"),". You also can find examples of how to reuse extensions.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/PSP34/Extensions/metadata"},"PSP34Metadata"),": metadata for PSP34."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/PSP34/Extensions/mintable"},"PSP34Mintable"),": creation of new tokens."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/PSP34/Extensions/burnable"},"PSP34Burnable"),": destruction of own tokens."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/PSP34/Extensions/enumerable"},"PSP34Enumerable"),": iterating over contract's tokens."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/PSP37/"},"PSP37")," is an example of how you can reuse the implementation of\n",(0,r.kt)("a",{parentName:"li",href:"https://github.com/Brushfam/openbrush-contracts/tree/main/contracts/token/psp37"},"psp37"),". You also can find examples of how to reuse extensions.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/PSP37/Extensions/metadata"},"PSP37Metadata"),": metadata for PSP37."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/PSP37/Extensions/mintable"},"PSP37Mintable"),": creation of new tokens."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/PSP37/Extensions/burnable"},"PSP37Burnable"),": destruction of own tokens."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/PSP37/Extensions/batch"},"PSP37Batch"),": batch transferring of tokens."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/PSP37/Extensions/enumerable"},"PSP37Enumerable"),": iterating over contract's tokens."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/access-control/"},"Access Control")," shows how you can use the implementation of\n",(0,r.kt)("a",{parentName:"li",href:"https://github.com/Brushfam/openbrush-contracts/tree/main/contracts/src/access/access_control"},"access-control")," and\n",(0,r.kt)("a",{parentName:"li",href:"https://github.com/Brushfam/openbrush-contracts/tree/main/contracts/src/token/psp34"},"psp34")," together to provide rights to mint and burn NFT tokens.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/access-control/Extensions/enumerable"},"AccessControlEnumerable"),": iterating over contract's roles."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/ownable"},"Ownable")," shows how you can use the implementation of\n",(0,r.kt)("a",{parentName:"li",href:"https://github.com/Brushfam/openbrush-contracts/tree/main/contracts/access/ownable"},"ownable")," and\n",(0,r.kt)("a",{parentName:"li",href:"https://github.com/Brushfam/openbrush-contracts/tree/main/contracts/token/psp37"},"psp37")," together to provide rights to mint and burn tokens."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/Brushfam/openbrush-contracts/tree/main/contracts/src/security/reentrancy_guard"},"ReentrancyGuard"),"\nmodifier to prevent reentrancy during certain functions."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/pausable"},"Pausable")," shows how you can use the implementation of\n",(0,r.kt)("a",{parentName:"li",href:"https://github.com/Brushfam/openbrush-contracts/tree/main/contracts/src/security/pausable"},"pausable"),"\ncontract and modifiers."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/timelock-controller"},"TimelockController")," shows how you can use the implementation of\n",(0,r.kt)("a",{parentName:"li",href:"https://github.com/Brushfam/openbrush-contracts/tree/main/contracts/src/governance/timelock_controller"},"timelock-controller"),"\nto execute a transaction with some delay via governance."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/openbrush-contracts/v4.0.0-beta/smart-contracts/payment-splitter"},"PaymentSplitter")," shows how you can use the implementation of\n",(0,r.kt)("a",{parentName:"li",href:"https://github.com/Brushfam/openbrush-contracts/tree/main/contracts/src/finance/payment_splitter"},"payment-splitter"),"\nto split received native tokens between participants of the contract.")))}m.isMDXComponent=!0}}]);